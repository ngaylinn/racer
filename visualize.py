"""Render simulations on screen or save to video.

The entrypoints for this module are show() and save(), which will render what's
happening in one of Simulator's parallel worlds. If the simulator is in debug
mode, then the views and reactions of each ball will be rendered in addition to
their position. When the simulation ends, the last frame will be shown for
longer, with the metrics and scores for that simulation overlaid in order to
see the final results.
"""

import os
import time
import warnings

import taichi as ti
from tqdm import trange

import ball
import constants as c

LAST_FRAME_SECS = 2
FRAME_RATE = 24


def render_topography(gui, simulator, w):
    # TODO: Optimize?
    gui.set_image(simulator.topographies.get_one(w))


def draw_x(gui, pos, color):
    offset = 7 / c.WORLD_SIZE
    gui.line(pos + ti.math.vec2( offset, offset),
             pos + ti.math.vec2(-offset, -offset), color=color)
    gui.line(pos + ti.math.vec2( offset, -offset),
             pos + ti.math.vec2(-offset, offset), color=color)


def render_debug(gui, simulator, w):
    # Draw a field of view for every ball.
    for b in range(c.NUM_BALLS):
        gui.circle(simulator.balls[w, b].pos, color=0xffffaa,
                   radius=c.VIEW_RADIUS_PX)
    # Layer on top arrows indicating status of each ball.
    for b in range(c.NUM_BALLS):
        direction = ti.math.vec2(simulator.views[w, b][ball.NRST_POS_X],
                                 simulator.views[w, b][ball.NRST_POS_Y])
        # Draw arrows from each ball to the nearest ball it can see.
        gui.arrow(simulator.balls[w, b].pos, direction, color=0x0000ff)

        # Also draw an arrow indicating this ball's intended direction.
        direction = ti.math.vec2([simulator.reactions[w, b][ball.ACC_X],
                                  simulator.reactions[w, b][ball.ACC_Y]])
        gui.arrow(simulator.balls[w, b].pos, direction, color=0xff00ff)

    # Draw a centroid for all the balls.
    draw_x(gui, simulator.avg_pos[w], 0x0000ff)


def render_balls(gui, simulator, w):
    # Draw a circle for every ball.
    for b in range(c.NUM_BALLS):
        ball = simulator.balls[w, b]
        gui.circle(ball.pos, radius=ball.radius_px(), color=0x0000ff)


def simulate_and_render_step(gui, simulator, w):
    render_topography(gui, simulator, w)
    simulator.view_and_react()
    if simulator.debug:
        render_debug(gui, simulator, w)
    simulator.update_balls()
    render_balls(gui, simulator, w)


def render_data(gui, metrics, scores):
    """Render all metrics and scores for this simulation as an overlay."""
    # Metrics is a DataFrame generated by Simulator, already restricted to just
    # the metrics from the world to record. Go through its columns and print
    # the value of any column that isn't recognized as metadata.
    index = 0
    for name in metrics.columns:
        if name.endswith('_index') or name in ['trial', 'world']:
            continue
        value = metrics[name].iloc[0]
        gui.text(f'{name}: {value:0.3f}',
                 (0.5, 1.0 - 0.05 * index),
                 font_size=20, color=0xff00ff)
        index += 1

    # We don't actually use a DataFrame for scores, since we're literally
    # scoring a single simulation.
    for index, (name, value) in enumerate(scores.items()):
        gui.text(f'{name}: {value:0.3f}',
                 (0, 1.0 - 0.05 * index),
                 font_size=20, color=0xff00ff)


def show(simulator, world_index, get_scores):
    gui = ti.GUI('Racer', c.WORLD_SHAPE,
                 background_color=0xffffff, show_gui=True)
    step = 0
    while gui.running:
        simulator.randomize_balls()
        for _ in range(c.NUM_STEPS):
            simulate_and_render_step(gui, simulator, world_index)
            # Show metrics and scores on every frame in debug mode.
            if simulator.debug:
                metrics = simulator.get_metrics()
                metrics = metrics[metrics['world'] == world_index]
                render_data(gui, metrics, get_scores(metrics))
            gui.show()
        # Only show metrics and scores on the last frame, otherwise.
        if not simulator.debug:
            metrics = simulator.get_metrics()
            metrics = metrics[metrics['world'] == world_index]
            render_data(gui, metrics, get_scores(metrics))
            gui.show()
        time.sleep(LAST_FRAME_SECS)


def save(simulator, world_index, get_scores, filename):
    gui = ti.GUI('Racer', c.WORLD_SHAPE,
                 background_color=0xffffff, show_gui=False)
    video_manager = ti.tools.VideoManager(
        output_dir='output', framerate=FRAME_RATE, automatic_build=False)
    simulator.randomize_balls()

    # Saving videos is slow, so show a progress bar.
    progress = trange(c.NUM_STEPS + LAST_FRAME_SECS * FRAME_RATE,
                      desc='Making Video')

    # Record the main simulation.
    for _ in range(c.NUM_STEPS):
        gui.clear()
        simulate_and_render_step(gui, simulator, world_index)
        # Show metrics and scores on every frame in debug mode.
        if simulator.debug:
            metrics = simulator.get_metrics()
            metrics = metrics[metrics['world'] == world_index]
            render_data(gui, metrics, get_scores(metrics))
        # Ignore spurious warnings from Taichi's image writing code.
        with warnings.catch_warnings():
            warnings.simplefilter('ignore')
            video_manager.write_frame(gui.get_image())
        progress.update()

    # Hold the last frame for longer, and show the stats.
    for _ in range(LAST_FRAME_SECS * FRAME_RATE):
        # Ignore spurious warnings from Taichi's image writing code.
        with warnings.catch_warnings():
            warnings.simplefilter('ignore')
            video_manager.write_frame(gui.get_image())
        metrics = simulator.get_metrics()
        metrics = metrics[metrics['world'] == world_index]
        render_data(gui, metrics, get_scores(metrics))
        progress.update()

    # Actually save the file.
    video_manager.make_video(gif=False, mp4=True)
    os.rename(video_manager.get_output_filename('.mp4'), filename)
